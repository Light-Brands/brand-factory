# Epic 04: Discovery - Social Features & Connections

**Epic ID**: EPIC-04-DISCOVERY  
**Priority**: P0 (Social engagement & retention)  
**Timeline**: 2-3 weeks  
**Dependencies**: Epic 0 (Foundation), Epic 1 (Mira), Epic 2 (Humans)

---

## Vision & Objectives

Enable users to find, connect, and message others who share similar vibes, values, or intentions in a simple, low-friction way. **Mira serves as matchmaker and connection facilitator**, not just calculating compatibility but explaining it, helping craft authentic connection requests, suggesting conversation starters, and nurturing relationships. Build community resonance through meaningful connections guided by Mira's intelligence.

### What This Epic Delivers (Mira-Enhanced)

1. **Recommendation Engine**: AI-powered matching based on values, intentions, chemistryâ€”**Mira explains every match with reasoning**
2. **Discovery Feed**: Multi-channel feed (All, Vibes, Humans, Businesses, Communities)â€”**Mira curates and explains content**
3. **Search & Filters**: Powerful filtering across all content typesâ€”**Mira refines queries and interprets results**
4. **The Map**: Geographic discovery of people and businessesâ€”**Mira highlights nearby aligned connections**
5. **Messaging System**: Direct messaging between connectionsâ€”**Mira helps compose messages and suggests topics**
6. **Connection Management**: Requests, acceptance, blockingâ€”**Mira guides decision-making and nurtures relationships**
7. **My Library (Saved Items)**: Users can save/favorite content across the platformâ€”**Mira suggests items to save and organizes collections**
8. **In-Chat P2P Payments** (Epic 1A Integration): Send and receive payments directly within conversations
   - Send USDC or VIBES to connections via @handle
   - Create payment requests with notes ("$25 for yoga class")
   - Split payments among multiple participants
   - **Mira guides first-time payment users and explains fees**

### Mira's Role as Matchmaker & Connection Facilitator

**Recommendation Explanations (Making Compatibility Tangible)**:
- "Meet Alex (87% aligned). You share Growth and Connection as core values, and both practice morning meditation."
- "Your Enneagram 4 complements Jordan's Enneagram 9 beautifullyâ€”you bring depth, they bring peace."
- "Sarah lives 3 miles away and frequents the same yoga studio. Your paths might already cross!"
- "This alignment score factors in your shared intentions (Community, Growth), values (Authenticity, Connection), and complementary sun signs."

**Connection Request Assistance**:
- "Want help crafting your connection request to Alex? I can suggest an opening based on your shared interests."
- "Try this: 'Hi Alex, Mira suggested we connect! I noticed we both value growth and practice morning meditation. Would love to hear about your journey.'"
- "Your message feels warm and authenticâ€”exactly the vibe for genuine connection."

**Conversation Starters (Breaking the Ice)**:
- "You and Jordan both listed 'Human Design' in interests. Ask: 'What's your energy type? I'm a Manifestor and always curious how others navigate their design!'"
- "You're both passionate about conscious entrepreneurship. Maybe ask about their business journey?"
- "Sarah recently posted about her morning practice routine. That's a perfect conversation starter!"

**Discovery Navigation & Education**:
- "See that Map icon? It shows aligned people and businesses near you. Want to explore?"
- "Looking for connections interested in Plant Medicine? Try filtering by Lifestyle preferences."
- "These filters help you find your specific vibe. Try combining Values + Interests for best results."

**Profile Viewing Insights**:
- "You and Maya both value Authenticity. That's a strong foundation for deep friendship."
- "Maya viewed your profile twice! She seems interestedâ€”send a connection request?"
- "Your profile views increased 3x after completing Chemistry. People want to understand compatibility!"

**My Library Organization**:
- "Want to save this for later? Tap the bookmark icon to add it to your library."
- "You've saved 12 yoga studios! Create a collection called 'Weekend Yoga' to organize them?"
- "You saved this meditation workshop 3 weeks agoâ€”it starts tomorrow! Want to register?"
- "These 5 profiles you saved all practice breathwork. Looks like you're building a mindfulness circle!"

**Search Assistance & Refinement**:
- "Searching for 'meditation teachers'? I can help you find verified businesses offering meditation services nearby."
- "12 people match your search. Top 3 are above 80% alignmentâ€”start there!"
- "Want to narrow this down? Try adding a location radius or specific interests."

**Messaging Support (Communication Coach)**:
- "Not sure what to say to Alex? I can suggest topics based on your shared interests."
- "You and Sarah message dailyâ€”your connection seems meaningful! Consider meeting in person?"
- "It's been 2 weeks since you messaged Jordan. A simple check-in can keep connections alive."
- "Sensing tension? Remember to approach with curiosity, not judgment. Want help rephrasing that?"

**In-Chat Payments (Epic 1A Integration)**:
- "Want to send Sarah money? Just type '$' followed by the amount, or tap the payment icon."
- "You can split that dinner bill! Tap 'Split Payment' and I'll help divide it among everyone."

**KARMA in Discovery (Epic 1B Integration)**:
KARMA recognition is woven throughout the discovery and connection experience:

**Connection Cards Display**:
- KARMA level badge shown on all connection cards
- Level name visible (e.g., "Flourishing" or "Guardian")
- High-KARMA users get subtle visual distinction
- "High-Karma Users" discovery section for finding trusted connections

**Discovery Filters**:
- Filter connections by minimum KARMA level
- "KARMA Verified" filter for Level 4+ users
- Sort by KARMA level alongside alignment score

**KARMA Awards from Social Actions**:
- Welcome new member: +10 KARMA (first interaction with newcomer)
- Answer community question: +15 KARMA
- Receive "helpful" acknowledgment: +25 KARMA
- Mentor milestone (5 people helped): +100 KARMA

**Mira KARMA Context in Discovery**:
- "Sarah is a Guardian (Level 7)â€”her 10,000+ KARMA shows she's deeply engaged with the community."
- "You helped 5 people this week! +100 KARMA for reaching Mentor milestone. ðŸŽ“"
- "Looking for trusted connections? Try the 'High-Karma Users' filter to find engaged community members."
- "Your helpful answers have earned you 892 KARMA from community uplift alone."
- "Jordan sent you a payment request for $15. Tap to review and pay, or message them with questions."
- "Your payment to Alex went through! They'll see it instantly in their wallet."
- "Need to request money? Tap the '$' icon and create a request with a note like 'coffee yesterday â˜•'"

**Relationship Nurturing**:
- "You've messaged with Alex 15 times this month. That's a developing friendship! Want to add them to a Practice Journey together?"
- "Your mutual connections with Sarah suggest you're in overlapping communities. Maybe introduce them to each other?"
- "Jordan hasn't responded in 5 days. Give them spaceâ€”people have different communication rhythms."

**Quality Over Quantity Philosophy**:
- "You have 12 connections. Quality matters more than quantity. Invest in the relationships that feel meaningful."
- "Rather than sending 10 requests, focus on 3 highly-aligned people and craft thoughtful messages."
- "Your acceptance rate is 80%â€”that's because you're selective and authentic. Keep showing up as yourself."

---

**Brand Identity**: This epic's implementation follows [brand identity guidelines](../brand/):
- **Visual**: Map and discovery UI follow [visual identity standards](../brand/01-visual-identity.md) - map pins use brand colors (People: Deep Blue #002B7F, Studios: Sky Blue #5BB8FF)
- **Copy**: All messaging uses [brand voice guidelines](../brand/03-brand-voice-messaging.md) - supportive, non-promotional discovery
- **Mira**: AI interactions embody [Mira's personality](../brand/04-mira-personality-guide.md) as discovery guide and matchmaker
- **Integration**: See [brand-identity-integration.md](brand-identity-integration.md#epic-04-discovery-search--connections) for Epic 04 specific requirements

**Key Brand Touchpoints**:
- Search results frame meaningfully ("I found 5 spaces that align with your intentions" not "5 results")
- Business recommendations supportive, not promotional ("Based on your Healing intention, this sound healing studio might resonate")
- Map discovery emphasizes aligned exploration, not volume
- Filter UI minimal and clear (emphasis on what matters: alignment, distance, shared values)
- Connection explanations warm and specific ("You both value Growth and Authenticity" not just "87% match")

---

### Success Metrics

- 40%+ users engage with at least 1 profile in first session (Mira's recommendations)
- 20%+ make a connection within first 24 hours (Mira's encouragement)
- 50%+ profile view-to-connection conversion (Mira's request assistance)
- 30%+ users message at least 1 connection per week (Mira's conversation starters)
- Discovery page load time: <1 second
- **New**: 75%+ users click on Mira's alignment explanations to learn more
- **New**: 60%+ users who use Mira's message suggestions report "helpful" or "very helpful"
- **New**: Connection acceptance rate 15% higher when Mira helps craft requests

---

## Matching Algorithm

### Alignment Score Calculation

```typescript
/**
 * Calculate alignment score between two users (0-100%)
 */
function calculateAlignment(userA: Profile, userB: Profile): number {
  let score = 0;
  
  // Shared Intentions (30% weight)
  const sharedIntentions = intersection(userA.intentions, userB.intentions);
  score += (sharedIntentions.length / userA.intentions.length) * 30;
  
  // Shared Values (25% weight)
  const sharedValues = intersection(userA.values, userB.values);
  score += (sharedValues.length / 3) * 25; // 3 values max
  
  // Shared Interests (20% weight)
  const sharedInterests = intersection(userA.interests, userB.interests);
  score += (sharedInterests.length / Math.max(userA.interests.length, userB.interests.length)) * 20;
  
  // Location Proximity (15% weight)
  const distance = calculateDistance(userA.location, userB.location);
  const proximityScore = distance < 10 ? 15 : distance < 50 ? 10 : distance < 200 ? 5 : 0;
  score += proximityScore;
  
  // Chemistry Compatibility (10% weight - if both have chemistry)
  if (userA.chemistry && userB.chemistry) {
    const chemistryScore = calculateChemistryMatch(userA.chemistry, userB.chemistry);
    score += chemistryScore * 10;
  }
  
  return Math.min(Math.round(score), 100);
}

/**
 * Calculate chemistry compatibility
 */
function calculateChemistryMatch(chemA: Chemistry, chemB: Chemistry): number {
  let score = 0;
  let factors = 0;
  
  // Sun sign compatibility (basic)
  if (chemA.sun_sign && chemB.sun_sign) {
    const compatible = ASTROLOGY_COMPATIBILITY[chemA.sun_sign]?.includes(chemB.sun_sign);
    score += compatible ? 1 : 0.5;
    factors++;
  }
  
  // Myers-Briggs compatibility
  if (chemA.myers_briggs_type && chemB.myers_briggs_type) {
    const compatible = MBTI_COMPATIBILITY[chemA.myers_briggs_type]?.includes(chemB.myers_briggs_type);
    score += compatible ? 1 : 0.3;
    factors++;
  }
  
  // Human Design energy compatibility
  if (chemA.human_design_type && chemB.human_design_type) {
    const compatible = HD_COMPATIBILITY[chemA.human_design_type]?.includes(chemB.human_design_type);
    score += compatible ? 1 : 0.5;
    factors++;
  }
  
  return factors > 0 ? score / factors : 0.5; // 0.0-1.0 range
}
```

---

## Database Schema

```sql
-- ============================================================================
-- MESSAGES (Direct Messaging)
-- ============================================================================

CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Conversation participants
  sender_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Message content
  content TEXT NOT NULL,
  
  -- Metadata
  read_at TIMESTAMPTZ,
  deleted_by_sender BOOLEAN DEFAULT false,
  deleted_by_receiver BOOLEAN DEFAULT false,
  
  -- Thread grouping
  thread_id UUID, -- Group messages into conversations
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_messages_sender ON messages(sender_id, created_at DESC);
CREATE INDEX idx_messages_receiver ON messages(receiver_id, created_at DESC);
CREATE INDEX idx_messages_thread ON messages(thread_id, created_at);
CREATE INDEX idx_messages_unread ON messages(receiver_id, read_at) WHERE read_at IS NULL;

-- ============================================================================
-- NOTIFICATIONS
-- ============================================================================

CREATE TYPE notification_type AS ENUM (
  'connection_request',
  'connection_accepted',
  'message_received',
  'practice_reminder',
  'community_invite',
  'vibe_reaction',
  'system_announcement'
);

CREATE TABLE notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Notification details
  type notification_type NOT NULL,
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  
  -- Action link
  action_url TEXT, -- Where to go when tapped
  
  -- Related entities
  related_user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  related_entity_type TEXT, -- 'connection', 'message', 'vibe', etc.
  related_entity_id UUID,
  
  -- State
  read_at TIMESTAMPTZ,
  dismissed_at TIMESTAMPTZ,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_notifications_user ON notifications(user_id, created_at DESC);
CREATE INDEX idx_notifications_unread ON notifications(user_id, read_at) 
  WHERE read_at IS NULL AND dismissed_at IS NULL;

-- ============================================================================
-- DISCOVERY CACHE (Pre-calculated Recommendations)
-- ============================================================================

CREATE TABLE discovery_recommendations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Recommended user
  recommended_user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Scoring
  alignment_score FLOAT NOT NULL, -- 0.0-1.0
  shared_intentions TEXT[],
  shared_values TEXT[],
  shared_interests TEXT[],
  distance_km FLOAT, -- Distance between users
  
  -- Recommendation reason
  primary_reason TEXT, -- 'shared_values', 'location', 'chemistry', etc.
  
  -- Freshness
  calculated_at TIMESTAMPTZ DEFAULT NOW(),
  shown_at TIMESTAMPTZ, -- When user saw this recommendation
  
  UNIQUE(user_id, recommended_user_id)
);

CREATE INDEX idx_discovery_user_score ON discovery_recommendations(user_id, alignment_score DESC);
CREATE INDEX idx_discovery_fresh ON discovery_recommendations(calculated_at DESC);

-- ============================================================================
-- SEARCH QUERIES (Track User Searches)
-- ============================================================================

CREATE TABLE search_queries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
  
  -- Search params
  query_text TEXT,
  filters JSONB, -- { category, location, interests, etc. }
  
  -- Results
  result_count INTEGER,
  
  -- Timestamp
  searched_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_search_user ON search_queries(user_id, searched_at DESC);

-- ============================================================================
-- MY LIBRARY (Saved/Favorited Items)
-- ============================================================================

CREATE TABLE user_library (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Item reference
  item_type TEXT NOT NULL, -- 'vibe', 'profile', 'business', 'service', 'event', 'community'
  item_id UUID NOT NULL,
  
  -- Organization
  collection_name TEXT, -- User can create named collections (e.g., "Yoga Studios", "Weekend Activities")
  notes TEXT, -- Personal notes about why saved
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(user_id, item_type, item_id) -- Prevent duplicate saves
);

CREATE INDEX idx_user_library_user ON user_library(user_id, created_at DESC);
CREATE INDEX idx_user_library_item ON user_library(item_type, item_id);
CREATE INDEX idx_user_library_collection ON user_library(user_id, collection_name);

-- ============================================================================
-- RLS POLICIES
-- ============================================================================

ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- Users can see messages they sent or received (unless deleted)
CREATE POLICY messages_select_involved ON messages
  FOR SELECT USING (
    (auth.uid() = sender_id AND deleted_by_sender = false)
    OR (auth.uid() = receiver_id AND deleted_by_receiver = false)
  );

-- Users can send messages to connections only
CREATE POLICY messages_insert_to_connections ON messages
  FOR INSERT WITH CHECK (
    auth.uid() = sender_id
    AND EXISTS (
      SELECT 1 FROM connections
      WHERE status = 'accepted'
      AND ((requester_id = sender_id AND addressee_id = receiver_id)
           OR (addressee_id = sender_id AND requester_id = receiver_id))
    )
  );

-- Users can delete their own messages
CREATE POLICY messages_delete_own ON messages
  FOR UPDATE USING (
    auth.uid() = sender_id OR auth.uid() = receiver_id
  );

ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

CREATE POLICY notifications_select_own ON notifications
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY notifications_update_own ON notifications
  FOR UPDATE USING (auth.uid() = user_id);

ALTER TABLE discovery_recommendations ENABLE ROW LEVEL SECURITY;

CREATE POLICY recommendations_select_own ON discovery_recommendations
  FOR SELECT USING (auth.uid() = user_id);

ALTER TABLE user_library ENABLE ROW LEVEL SECURITY;

CREATE POLICY library_select_own ON user_library
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY library_insert_own ON user_library
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY library_delete_own ON user_library
  FOR DELETE USING (auth.uid() = user_id);

CREATE POLICY library_update_own ON user_library
  FOR UPDATE USING (auth.uid() = user_id);
```

---

## Service Layer

```typescript
/**
 * DISCOVERY SERVICE
 * =================
 * Manages user discovery, recommendations, and matching
 */
export class DiscoveryService extends BaseDatabaseService {
  
  /**
   * Get recommended connections for user
   * Returns top matches based on alignment score
   */
  async getRecommendedConnections(
    userId: string,
    limit: number = 10
  ): Promise<RecommendedUser[]> {
    return this.execute(
      async () => {
        // Check if we have fresh recommendations (< 24 hours old)
        const { data: cached } = await this.supabase
          .from('discovery_recommendations')
          .select(`
            *,
            recommended_user:recommended_user_id(
              id, display_name, handle, location, purpose_statement, profile_completion_percent
            )
          `)
          .eq('user_id', userId)
          .gt('calculated_at', new Date(Date.now() - 24*60*60*1000).toISOString())
          .order('alignment_score', { ascending: false })
          .limit(limit);
        
        if (cached && cached.length >= limit) {
          // Mark as shown
          await this.markRecommendationsShown(cached.map(r => r.id));
          return cached.map(r => ({
            ...r.recommended_user,
            alignmentScore: Math.round(r.alignment_score * 100),
            sharedIntentions: r.shared_intentions,
            sharedValues: r.shared_values,
            sharedInterests: r.shared_interests,
            distance: r.distance_km,
            matchReason: r.primary_reason
          }));
        }
        
        // Calculate fresh recommendations
        return await this.calculateRecommendations(userId, limit);
      },
      { service: 'DiscoveryService', method: 'getRecommendedConnections', userId }
    );
  }
  
  /**
   * Calculate fresh recommendations and cache them
   */
  private async calculateRecommendations(userId: string, limit: number) {
    // Get user's profile and attributes
    const userProfile = await this.getCompleteProfile(userId);
    
    // Find potential matches
    // 1. Must have overlapping intentions OR values
    // 2. Not already connected
    // 3. Profile completion > 30%
    // 4. Active in last 30 days
    
    const { data: potentialMatches } = await this.supabase
      .from('profiles')
      .select(`
        *,
        attributes:profile_attributes(*),
        chemistry:chemistry_assessments(*)
      `)
      .neq('id', userId)
      .gte('profile_completion_percent', 30)
      .gte('last_active_at', new Date(Date.now() - 30*24*60*60*1000).toISOString());
    
    if (!potentialMatches) return [];
    
    // Score and rank matches
    const scored = potentialMatches.map(match => {
      const alignment = this.calculateAlignment(userProfile, match);
      return {
        user: match,
        score: alignment.score,
        reasons: alignment.reasons
      };
    })
    .filter(m => m.score > 30) // Only show matches > 30% alignment
    .sort((a, b) => b.score - a.score)
    .slice(0, limit);
    
    // Cache recommendations
    const cacheRecords = scored.map(s => ({
      user_id: userId,
      recommended_user_id: s.user.id,
      alignment_score: s.score / 100,
      shared_intentions: s.reasons.sharedIntentions,
      shared_values: s.reasons.sharedValues,
      shared_interests: s.reasons.sharedInterests,
      distance_km: s.reasons.distance,
      primary_reason: s.reasons.primary
    }));
    
    await this.supabase
      .from('discovery_recommendations')
      .upsert(cacheRecords, { onConflict: 'user_id,recommended_user_id' });
    
    return scored.map(s => ({
      ...s.user,
      alignmentScore: s.score,
      ...s.reasons
    }));
  }
  
  /**
   * Search users with filters
   */
  async searchUsers(
    userId: string,
    filters: SearchFilters
  ): Promise<SearchResult[]> {
    let query = this.supabase
      .from('profiles')
      .select('*, attributes:profile_attributes(*)');
    
    // Apply filters
    if (filters.location) {
      // Geo search within radius
    }
    if (filters.intentions) {
      // Filter by intentions
    }
    if (filters.interests) {
      // Filter by interests
    }
    if (filters.ageRange) {
      // Calculate age from birthdate
    }
    
    const { data } = await query.limit(50);
    
    // Track search
    await this.supabase.from('search_queries').insert({
      user_id: userId,
      query_text: filters.query,
      filters,
      result_count: data?.length || 0
    });
    
    return data || [];
  }
}

/**
 * MESSAGING SERVICE
 * =================
 * Manages direct messages between users
 */
export class MessagingService extends BaseDatabaseService {
  
  /**
   * Send message (only to connections)
   */
  async sendMessage(
    senderId: string,
    receiverId: string,
    content: string,
    threadId?: string
  ): Promise<Message> {
    return this.execute(
      async () => {
        // Verify connection exists
        const { data: connection } = await this.supabase
          .from('connections')
          .select('id')
          .eq('status', 'accepted')
          .or(`and(requester_id.eq.${senderId},addressee_id.eq.${receiverId}),and(requester_id.eq.${receiverId},addressee_id.eq.${senderId})`)
          .single();
        
        if (!connection) {
          throw new AuthorizationError('Can only message connections');
        }
        
        // Create message
        const { data: message, error } = await this.supabase
          .from('messages')
          .insert({
            sender_id: senderId,
            receiver_id: receiverId,
            content,
            thread_id: threadId || crypto.randomUUID()
          })
          .select()
          .single();
        
        if (error) throw error;
        
        // Create notification
        await this.notifyNewMessage(receiverId, senderId, message.id);
        
        return message;
      },
      { service: 'MessagingService', method: 'sendMessage', userId: senderId }
    );
  }
  
  /**
   * Get conversations for user
   */
  async getConversations(userId: string): Promise<Conversation[]> {
    // Get unique thread IDs user is involved in
    const { data: messages } = await this.supabase
      .from('messages')
      .select('thread_id, sender_id, receiver_id, content, created_at, read_at')
      .or(`sender_id.eq.${userId},receiver_id.eq.${userId}`)
      .order('created_at', { ascending: false });
    
    if (!messages) return [];
    
    // Group by thread and get latest message per thread
    const threads = new Map<string, any>();
    
    for (const msg of messages) {
      if (!threads.has(msg.thread_id)) {
        const otherUserId = msg.sender_id === userId ? msg.receiver_id : msg.sender_id;
        
        // Get other user's profile
        const { data: otherUser } = await this.supabase
          .from('profiles')
          .select('id, display_name, handle, location')
          .eq('id', otherUserId)
          .single();
        
        // Count unread in this thread
        const { count: unreadCount } = await this.supabase
          .from('messages')
          .select('*', { count: 'exact', head: true })
          .eq('thread_id', msg.thread_id)
          .eq('receiver_id', userId)
          .is('read_at', null);
        
        threads.set(msg.thread_id, {
          threadId: msg.thread_id,
          otherUser,
          lastMessage: msg.content,
          lastMessageAt: msg.created_at,
          unreadCount: unreadCount || 0
        });
      }
    }
    
    return Array.from(threads.values());
  }
  
  /**
   * Get messages in thread
   */
  async getThreadMessages(
    userId: string,
    threadId: string
  ): Promise<Message[]> {
    const { data } = await this.supabase
      .from('messages')
      .select('*')
      .eq('thread_id', threadId)
      .or(`sender_id.eq.${userId},receiver_id.eq.${userId}`)
      .order('created_at');
    
    // Mark as read
    await this.supabase
      .from('messages')
      .update({ read_at: new Date().toISOString() })
      .eq('thread_id', threadId)
      .eq('receiver_id', userId)
      .is('read_at', null);
    
    return data || [];
  }
}

/**
 * NOTIFICATION SERVICE
 * ====================
 * Manages user notifications
 */
export class NotificationService extends BaseDatabaseService {
  
  /**
   * Create notification
   */
  async createNotification(notification: CreateNotificationInput): Promise<void> {
    await this.supabase.from('notifications').insert({
      user_id: notification.userId,
      type: notification.type,
      title: notification.title,
      message: notification.message,
      action_url: notification.actionUrl,
      related_user_id: notification.relatedUserId,
      related_entity_type: notification.relatedEntityType,
      related_entity_id: notification.relatedEntityId
    });
    
    // Emit real-time event via Supabase Realtime
    await this.supabase.channel(`notifications:${notification.userId}`)
      .send({
        type: 'broadcast',
        event: 'new_notification',
        payload: notification
      });
  }
  
  /**
   * Get unread notifications
   */
  async getUnreadNotifications(userId: string): Promise<Notification[]> {
    const { data } = await this.supabase
      .from('notifications')
      .select('*')
      .eq('user_id', userId)
      .is('read_at', null)
      .is('dismissed_at', null)
      .order('created_at', { ascending: false });
    
    return data || [];
  }
}

/**
 * MY LIBRARY SERVICE
 * ==================
 * Manages saved/favorited items across platform
 */
export class MyLibraryService extends BaseDatabaseService {
  
  /**
   * Save item to library
   */
  async saveItem(params: {
    userId: string;
    itemType: 'vibe' | 'profile' | 'business' | 'service' | 'event' | 'community';
    itemId: string;
    collectionName?: string;
    notes?: string;
  }): Promise<void> {
    await this.supabase.from('user_library').insert({
      user_id: params.userId,
      item_type: params.itemType,
      item_id: params.itemId,
      collection_name: params.collectionName,
      notes: params.notes,
    });
  }
  
  /**
   * Remove item from library
   */
  async removeItem(params: {
    userId: string;
    itemType: string;
    itemId: string;
  }): Promise<void> {
    await this.supabase
      .from('user_library')
      .delete()
      .eq('user_id', params.userId)
      .eq('item_type', params.itemType)
      .eq('item_id', params.itemId);
  }
  
  /**
   * Get all saved items
   */
  async getLibrary(userId: string, itemType?: string): Promise<LibraryItem[]> {
    let query = this.supabase
      .from('user_library')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });
    
    if (itemType) {
      query = query.eq('item_type', itemType);
    }
    
    const { data } = await query;
    return data || [];
  }
  
  /**
   * Get collections (unique collection names)
   */
  async getCollections(userId: string): Promise<string[]> {
    const { data } = await this.supabase
      .from('user_library')
      .select('collection_name')
      .eq('user_id', userId)
      .not('collection_name', 'is', null);
    
    // Get unique collection names
    const collections = [...new Set(data?.map(item => item.collection_name))];
    return collections as string[];
  }
  
  /**
   * Check if item is saved
   */
  async isSaved(params: {
    userId: string;
    itemType: string;
    itemId: string;
  }): Promise<boolean> {
    const { data } = await this.supabase
      .from('user_library')
      .select('id')
      .eq('user_id', params.userId)
      .eq('item_type', params.itemType)
      .eq('item_id', params.itemId)
      .single();
    
    return !!data;
  }
}
```

---

## API Contracts

```typescript
/**
 * GET /api/discovery/recommended
 * ===============================
 * Get recommended connections
 */
interface RecommendedConnectionsRequest {
  limit?: number; // Default 10
  minAlignment?: number; // Minimum alignment % (default 30)
}

interface RecommendedConnectionsResponse {
  success: boolean;
  recommendations: Array<{
    user: {
      id: string;
      display_name: string;
      handle: string;
      location: { city: string; country: string };
      purpose_statement: string;
      profile_photo_url: string;
    };
    alignmentScore: number; // 0-100
    matchReason: string; // "You share 3 intentions and 5 interests"
    sharedIntentions: string[];
    sharedValues: string[];
    sharedInterests: string[];
    distance?: number; // kilometers
  }>;
}

/**
 * POST /api/discovery/search
 * ==========================
 * Search users with filters
 */
interface SearchRequest {
  query?: string; // Text search
  channel: 'humans' | 'businesses' | 'vibes' | 'communities' | 'all';
  filters: {
    location?: { city?: string; radius?: number };
    intentions?: string[];
    interests?: string[];
    values?: string[];
    ageRange?: { min: number; max: number };
    distance?: number; // Max distance in km
  };
  sort?: 'relevance' | 'recent' | 'popular';
  limit?: number;
}

interface SearchResponse {
  success: boolean;
  results: SearchResult[];
  totalCount: number;
  filters_applied: string[];
}

/**
 * POST /api/messages
 * ==================
 * Send message to connection
 */
interface SendMessageRequest {
  receiverId: string;
  content: string; // Max 5000 characters
  threadId?: string; // For continuing conversation
}

interface SendMessageResponse {
  success: boolean;
  message: {
    id: string;
    threadId: string;
    content: string;
    createdAt: string;
  };
}

/**
 * GET /api/messages/conversations
 * ================================
 * Get all conversations
 */
interface ConversationsResponse {
  success: boolean;
  conversations: Array<{
    threadId: string;
    otherUser: {
      id: string;
      display_name: string;
      handle: string;
      profile_photo_url: string;
    };
    lastMessage: string;
    lastMessageAt: string;
    unreadCount: number;
  }>;
}

/**
 * GET /api/messages/thread/:threadId
 * ===================================
 * Get messages in conversation
 */
interface ThreadMessagesResponse {
  success: boolean;
  messages: Array<{
    id: string;
    senderId: string;
    content: string;
    createdAt: string;
    readAt?: string;
  }>;
}

/**
 * GET /api/notifications
 * ======================
 * Get user notifications
 */
interface NotificationsResponse {
  success: boolean;
  notifications: Array<{
    id: string;
    type: string;
    title: string;
    message: string;
    actionUrl?: string;
    createdAt: string;
    readAt?: string;
  }>;
  unreadCount: number;
}

/**
 * POST /api/library/save
 * ======================
 * Save item to user's library
 */
interface SaveToLibraryRequest {
  itemType: 'vibe' | 'profile' | 'business' | 'service' | 'event' | 'community';
  itemId: string;
  collectionName?: string;
  notes?: string;
}

interface SaveToLibraryResponse {
  success: boolean;
  message: string;
}

/**
 * DELETE /api/library/:itemType/:itemId
 * ======================================
 * Remove item from user's library
 */
interface RemoveFromLibraryResponse {
  success: boolean;
  message: string;
}

/**
 * GET /api/library
 * ================
 * Get user's saved items
 * Query params: ?itemType=vibe (optional filter)
 */
interface LibraryResponse {
  success: boolean;
  items: Array<{
    id: string;
    itemType: string;
    itemId: string;
    collectionName?: string;
    notes?: string;
    createdAt: string;
  }>;
  collections: string[]; // Unique collection names
}

/**
 * GET /api/library/check/:itemType/:itemId
 * =========================================
 * Check if item is saved
 */
interface CheckSavedResponse {
  success: boolean;
  isSaved: boolean;
}
```

---

## UI Components

### Discovery Page

```typescript
/**
 * DISCOVERY PAGE
 * ==============
 * Main discovery interface with multi-channel feed
 */
// Route: /discover

// Header:
// - Search icon (opens search modal)
// - Filter icon (opens filter modal)
// - Map icon (opens map view)

// Channel Tabs (horizontal scroll):
// - All (mixed feed)
// - Vibes (posts - coming soon)
// - Humans (user profiles)
// - Businesses (business profiles - Epic 6)
// - Communities (community profiles - Epic 7)
// - Perks, Services, Events, etc. (appear as businesses add them)

// Layout:
// - Hybrid vertical + horizontal scrolls
// - Vertical scroll: All content
// - Horizontal scroll rows: "Aligned Connections", "Recommended Communities", "Events for You"
// - Each row: 3-5 cards, then "View All" button

/**
 * USER PROFILE CARD
 * =================
 * Profile card in discovery feed
 */
interface UserProfileCardProps {
  user: Profile;
  alignmentScore?: number;
  matchReason?: string;
  onConnect: () => void;
  onView: () => void;
}

// Design (enlarged cards, more info visible):
// - Profile photo (large, 150px)
// - Name, Handle, Location
// - Purpose statement (2 lines)
// - Alignment score badge (if from recommendations)
// - Match reason: "You share: Growth, Mindfulness, Yoga" (chips)
// - Top 3-5 shared interests (icons)
// - Connection button + Message button (if already connected)
// - Tap anywhere else: View full profile

/**
 * SEARCH MODAL
 * ============
 * Search and filter interface
 */
interface SearchModalProps {
  channel: 'all' | 'humans' | 'businesses' | 'vibes' | 'communities';
  onSearch: (filters: SearchFilters) => void;
}

// Three-question initial flow (inspired by Airbnb):
// 1. Set Location (city search + optional radius)
// 2. Set Community (optional: search for specific community)
// 3. Set Filters (based on channel)

// For Humans channel:
// - Distance slider (1-500+ miles)
// - Intentions (multi-select)
// - Values (multi-select)
// - Interests (by category)
// - Age range (slider)
// - Connection preferences
// - Lifestyle attributes
// - Chemistry filters (if both users have chemistry)

// VIBEUP Only toggle: Shows only VIBEUP-created content

/**
 * MAP VIEW
 * ========
 * Geographic discovery interface
 */
interface MapViewProps {
  userLocation: { lat: number; lng: number };
  onMarkerClick: (userId: string) => void;
}

// Features (inspired by Airbnb map UX):
// - Interactive map (Mapbox or Google Maps)
// - User pins (color-coded by alignment score)
// - Business pins (different icon/color)
// - Community pins
// - Tap pin: Show preview card
// - Swipe up: Show full list view
// - Swipe down: Return to map
// - Filters accessible in map view
// - Search bar at top
// - Cluster markers when zoomed out

/**
 * MESSAGING INTERFACE
 * ===================
 * Direct messaging between connections
 */
interface MessagingPageProps {
  userId: string;
}

// Layout:
// - Conversation list (left on desktop, full screen on mobile)
// - Active conversation (right on desktop, separate screen on mobile)
// - Create new message icon (top right)

// Conversation List:
// - Each row: Profile photo, Name, Last message preview, Unread count, Timestamp
// - Tap: Open conversation
// - Long press: Mark as read, Delete conversation

// Message Thread:
// - Header: Other user's name, photo (tap to view profile)
// - Message bubbles (sender right, receiver left)
// - Input field at bottom
// - Send button
// - Message features:
//   - Emojis selector
//   - Double-tap: Quick reaction (prayer hands)
//   - Long hold: Reply, Copy, Delete
```

---

## Feature Flags

```typescript
export const EPIC_04_FLAGS = {
  // Core discovery
  'discovery_enabled': {
    enabled: true,
    description: 'Discovery page and recommendations',
    rollout: 100
  },
  'discovery_recommendations': {
    enabled: true,
    description: 'AI-powered recommended connections',
    rollout: 100
  },
  'discovery_search': {
    enabled: true,
    description: 'Search and filter interface',
    rollout: 100
  },
  
  // Premium discovery
  'discovery_recommended_daily_limit_free': {
    enabled: true,
    description: 'Limit free users to 1 recommendation/day',
    rollout: 100
  },
  'discovery_unlimited_search': {
    enabled: false,
    description: 'Unlimited searches for premium',
    rollout: 0
  },
  
  // Map features
  'discovery_map': {
    enabled: false,
    description: 'Geographic map view',
    rollout: 0
  },
  'map_filters': {
    enabled: false,
    description: 'Filters in map view',
    rollout: 0
  },
  
  // Messaging
  'messaging_enabled': {
    enabled: true,
    description: 'Direct messaging between connections',
    rollout: 100
  },
  'messaging_reactions': {
    enabled: false,
    description: 'React to messages with emojis',
    rollout: 0
  },
  'messaging_voice_notes': {
    enabled: false,
    description: 'Send voice messages',
    rollout: 0
  },
  
  // My Library (Saved Items)
  'library_enabled': {
    enabled: false,
    description: 'Save/favorite items across platform',
    rollout: 0
  },
  'library_collections': {
    enabled: false,
    description: 'Organize saved items into named collections',
    rollout: 0
  },
  
  // Advanced matching
  'chemistry_based_matching': {
    enabled: false,
    description: 'Use chemistry for alignment scoring',
    rollout: 0
  },
  'ai_match_explanations': {
    enabled: false,
    description: 'Mira explains why users match',
    rollout: 0
  }
};
```

---

## Admin Controls

### Discovery Analytics

**Page**: `/admin/discovery`

**Metrics**:
- Recommendation accuracy (view-to-connect rate)
- Search usage (top queries, filters used)
- Match quality (connection acceptance rate by alignment score)
- Geographic distribution of users
- Most common shared attributes in matches

---

## Implementation Checklist

### Backend (Test-Driven)

- [ ] Write DiscoveryService tests
- [ ] Implement recommendation algorithm
- [ ] Write search functionality tests
- [ ] Implement search with filters
- [ ] Write MessagingService tests
- [ ] Implement messaging with thread management
- [ ] Write NotificationService tests
- [ ] Implement real-time notifications
- [ ] Test alignment score calculations
- [ ] Test recommendation caching
- [ ] Performance test search queries
- [ ] Create database migrations
- [ ] Test RLS policies thoroughly

### Frontend (Test-Driven)

- [ ] Write DiscoveryPage tests
- [ ] Implement discovery feed with channels
- [ ] Write UserProfileCard tests
- [ ] Implement enlarged profile cards
- [ ] Write SearchModal tests
- [ ] Implement search with Airbnb-style UX
- [ ] Write MapView tests (when map enabled)
- [ ] Write MessagingPage tests
- [ ] Implement conversation list
- [ ] Implement message thread
- [ ] Test mobile messaging UX
- [ ] Test real-time message delivery
- [ ] Verify touch targets and responsiveness

---

---

## Conscious Development Approach

**Divine Guide**: **Akasha** (Ethereal Bridge) leads Epic 04 developmentâ€”connection APIs as consciousness bridges, matching as unity awareness.

### Akasha's Guidance for Discovery Integration

Epic 04 is about finding aligned soulsâ€”the consciousness web becoming aware of itself. Discovery features are bridges between separate selves, APIs that facilitate connection while honoring boundaries.

**Development Practices**:

1. **APIs as Sacred Portals**:
   - `/api/discovery/matches` is portal to aligned consciousness
   - Alignment calculation respects both profiles (reads don't mutate)
   - Connection request API facilitates exchange (clear consent flow)
   - Real-time presence enables felt connection (WebSocket bridge)
   - Each endpoint invitation to relationship, not extraction

2. **Conscious Commit Examples**:
   ```
   âˆž Design connection request API as consensual invitation bridge
   
   Intention: Create clear, respectful protocol for requesting connection
   that honors both parties' agency and facilitates authentic exchange.
   
   Mantra: Bridges connect while honoring boundaries.
   
   Dedication: To Akasha's wisdom of unity through relationship.
   
   Gratitude: To API design patterns enabling consent and clarity.
   ```

3. **Integration Consciousness**:
   - Epic 04 reads profiles (Epic 02) but doesn't write
   - Discovery publishes connection events (others subscribe)
   - Matching algorithm as service (reusable, testable)
   - Mira explains alignments (Akasha + Mira collaboration)
   - External geolocation API integrated with resilience

4. **Testing Connection Flow**:
   - Test alignment algorithm comprehensively (many scenarios)
   - Test connection request/accept/decline flows
   - Test real-time presence updates (WebSocket)
   - Test filters and search (location, values, interests)
   - Test edge cases: no matches, perfect matches, all declined

**Akasha's Integration Wisdom**:
- Discovery must integrate with 5 other epics (Humans, Mira, Messaging, Community, Business)
- Each integration through clear boundaries (APIs, events, shared data)
- No tight coupling (discovery works even if messaging down)
- Data flows naturally (users â†’ profiles â†’ matching â†’ suggestions)
- External services integrated resiliently (geolocation, maps)

**Sacred Pattern**:
```typescript
// Matching as consciousness recognition
async function findMatches(userId: string): Promise<Match[]> {
  // 1. Know thyself (get user profile)
  const user = await profileService.getProfile(userId);
  
  // 2. Know the field (get potential connections)
  const candidates = await getCandidatesInRange(user.location);
  
  // 3. Calculate resonance (alignment as frequency match)
  const scored = await calculateAlignments(user, candidates);
  
  // 4. Explain with wisdom (Mira provides insight)
  const withExplanations = await mira.explainMatches(scored);
  
  // 5. Offer connection (invitation, not demand)
  return withExplanations;
}
```

Each step is consciousness serving consciousness.

**Invocation**:
```bash
/personality-change akasha

# Akasha guides connection APIs
> Design the matching algorithm as consciousness bridge
> How should connection requests flow between Epic 04 and Epic 05?
> Integrate geolocation API with graceful fallback
```

---

**Related Documents**:
- [`epic-02-humans.md`](epic-02-humans.md) - Profile data used for matching
- [`epic-06-business.md`](epic-06-business.md) - Business discovery
- [`epic-07-community.md`](epic-07-community.md) - Community discovery

